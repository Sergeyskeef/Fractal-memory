# 04. Phase 3: –°–∞–º–æ–æ–±—É—á–µ–Ω–∏–µ (ReasoningBank)

## üéØ –¶–µ–ª—å

–†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Å–∏—Å—Ç–µ–º—É –æ–±—É—á–µ–Ω–∏—è –Ω–∞ —É—Å–ø–µ—Ö–∞—Ö –∏ –æ—à–∏–±–∫–∞—Ö.

**–í—Ä–µ–º—è**: 2-3 –¥–Ω—è  
**–†–µ–∑—É–ª—å—Ç–∞—Ç**: –ê–≥–µ–Ω—Ç —É—á–∏—Ç—Å—è –∏–∑ –æ–ø—ã—Ç–∞ –∏ –∏–∑–±–µ–≥–∞–µ—Ç –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏—è –æ—à–∏–±–æ–∫

---

## üìã –ß–µ–∫-–ª–∏—Å—Ç Phase 3

- [ ] ReasoningBank —Å–æ–∑–¥–∞–Ω
- [ ] Experience logging —Ä–∞–±–æ—Ç–∞–µ—Ç
- [ ] Strategy extraction —Ä–∞–±–æ—Ç–∞–µ—Ç
- [ ] Negative reinforcement —Ä–∞–±–æ—Ç–∞–µ—Ç
- [ ] –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –∞–≥–µ–Ω—Ç–æ–º
- [ ] –¢–µ—Å—Ç—ã –ø—Ä–æ—Ö–æ–¥—è—Ç

---

## üß† –ö–æ–Ω—Ü–µ–ø—Ü–∏—è —Å–∞–º–æ–æ–±—É—á–µ–Ω–∏—è

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                   –¶–ò–ö–õ –û–ë–£–ß–ï–ù–ò–Ø                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                         ‚îÇ
‚îÇ   1. RETRIEVE                                           ‚îÇ
‚îÇ      ‚îî‚îÄ –ù–∞–π—Ç–∏ –ø–æ—Ö–æ–∂–∏–µ –∑–∞–¥–∞—á–∏ –≤ –ø–∞–º—è—Ç–∏                  ‚îÇ
‚îÇ      ‚îî‚îÄ –ü–æ–ª—É—á–∏—Ç—å —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ (—É—Å–ø–µ—à–Ω—ã–µ –∏ –ø—Ä–æ–≤–∞–ª—å–Ω—ã–µ)     ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ   2. EXECUTE                                            ‚îÇ
‚îÇ      ‚îî‚îÄ –í—ã–ø–æ–ª–Ω–∏—Ç—å –∑–∞–¥–∞—á—É —Å —É—á—ë—Ç–æ–º —Å—Ç—Ä–∞—Ç–µ–≥–∏–π            ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ   3. JUDGE                                              ‚îÇ
‚îÇ      ‚îî‚îÄ –û—Ü–µ–Ω–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç (—É—Å–ø–µ—Ö/–ø—Ä–æ–≤–∞–ª)               ‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ   4. LEARN                                              ‚îÇ
‚îÇ      ‚îî‚îÄ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –æ–ø—ã—Ç                                 ‚îÇ
‚îÇ      ‚îî‚îÄ –û–±–Ω–æ–≤–∏—Ç—å confidence —Å—Ç—Ä–∞—Ç–µ–≥–∏–π                  ‚îÇ
‚îÇ      ‚îî‚îÄ –ò–∑–≤–ª–µ—á—å –Ω–æ–≤—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã                         ‚îÇ
‚îÇ                                                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## 1Ô∏è‚É£ ReasoningBank

### –§–∞–π–ª `src/core/learning.py`:

```python
"""
ReasoningBank ‚Äî —Å–∏—Å—Ç–µ–º–∞ —Å–∞–º–æ–æ–±—É—á–µ–Ω–∏—è –Ω–∞ –æ–ø—ã—Ç–µ.

–ö–ª—é—á–µ–≤—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏:
1. –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –æ–ø—ã—Ç–∞ (—É—Å–ø–µ—Ö–∏ –∏ –Ω–µ—É–¥–∞—á–∏)
2. –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–π –∏–∑ –æ–ø—ã—Ç–∞
3. Negative reinforcement (–æ–±—É—á–µ–Ω–∏–µ –Ω–∞ –æ—à–∏–±–∫–∞—Ö)
4. Strategy selection (–≤—ã–±–æ—Ä –ª—É—á—à–µ–π —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏)

–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:
    bank = ReasoningBank(graph_memory)
    
    # –ó–∞–ø–∏—Å–∞—Ç—å –æ–ø—ã—Ç
    await bank.log_experience(task, action, outcome)
    
    # –ù–∞–π—Ç–∏ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
    strategies = await bank.get_strategies_for_task(task)
    
    # –û–±–Ω–æ–≤–∏—Ç—å –ø–æ—Å–ª–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
    await bank.update_strategy_feedback(strategy_id, outcome)
"""

from dataclasses import dataclass, field
from datetime import datetime
from typing import List, Dict, Optional
from enum import Enum
import logging
import json
import uuid
import numpy as np

from .graphiti_adapter import GraphMemoryInterface, Episode

logger = logging.getLogger(__name__)


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# –ú–û–î–ï–õ–ò
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class Outcome(Enum):
    """–†–µ–∑—É–ª—å—Ç–∞—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∑–∞–¥–∞—á–∏"""
    SUCCESS = "success"
    FAILURE = "failure"
    PARTIAL = "partial"
    UNKNOWN = "unknown"


@dataclass
class Experience:
    """–ó–∞–ø–∏—Å–∞–Ω–Ω—ã–π –æ–ø—ã—Ç"""
    id: str
    task_description: str
    task_type: str
    context: Dict
    action_taken: str
    outcome: Outcome
    reasoning: str
    error_message: Optional[str] = None
    timestamp: datetime = field(default_factory=datetime.now)
    metadata: Dict = field(default_factory=dict)


@dataclass
class Strategy:
    """–ò–∑–≤–ª–µ—á—ë–Ω–Ω–∞—è —Å—Ç—Ä–∞—Ç–µ–≥–∏—è"""
    id: str
    description: str
    task_types: List[str]  # –î–ª—è –∫–∞–∫–∏—Ö –∑–∞–¥–∞—á –ø—Ä–∏–º–µ–Ω–∏–º–∞
    success_count: int = 0
    failure_count: int = 0
    confidence: float = 0.5
    created_at: datetime = field(default_factory=datetime.now)
    last_used: Optional[datetime] = None
    metadata: Dict = field(default_factory=dict)
    
    @property
    def success_rate(self) -> float:
        """–ü—Ä–æ—Ü–µ–Ω—Ç —É—Å–ø–µ—Ö–∞"""
        total = self.success_count + self.failure_count
        if total == 0:
            return 0.5  # –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö ‚Üí –Ω–µ–π—Ç—Ä–∞–ª—å–Ω–∞—è –æ—Ü–µ–Ω–∫–∞
        return self.success_count / total
    
    @property
    def total_uses(self) -> int:
        """–í—Å–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–π"""
        return self.success_count + self.failure_count
    
    def to_dict(self) -> Dict:
        """–°–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤ dict"""
        return {
            "id": self.id,
            "description": self.description,
            "task_types": self.task_types,
            "success_count": self.success_count,
            "failure_count": self.failure_count,
            "confidence": self.confidence,
            "created_at": self.created_at.isoformat(),
            "last_used": self.last_used.isoformat() if self.last_used else None,
            "success_rate": self.success_rate
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> "Strategy":
        """–î–µ—Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–∑ dict"""
        return cls(
            id=data["id"],
            description=data["description"],
            task_types=data.get("task_types", []),
            success_count=data.get("success_count", 0),
            failure_count=data.get("failure_count", 0),
            confidence=data.get("confidence", 0.5),
            created_at=datetime.fromisoformat(data["created_at"]) if "created_at" in data else datetime.now(),
            last_used=datetime.fromisoformat(data["last_used"]) if data.get("last_used") else None
        )


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# REASONING BANK
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class ReasoningBank:
    """
    –ë–∞–Ω–∫ —Å—Ç—Ä–∞—Ç–µ–≥–∏–π –∏ –æ–ø—ã—Ç–∞ –¥–ª—è —Å–∞–º–æ–æ–±—É—á–µ–Ω–∏—è.
    """
    
    def __init__(
        self, 
        graph: GraphMemoryInterface,
        config: Dict = None
    ):
        """
        Args:
            graph: GraphMemory –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è
            config: {
                "experience_buffer_size": 100,
                "min_experiences_for_strategy": 3,
                "confidence_boost": 0.05,
                "confidence_penalty": 0.1,
                "exploration_rate": 0.1
            }
        """
        self.graph = graph
        self.config = config or {}
        
        # –ë—É—Ñ–µ—Ä –æ–ø—ã—Ç–∞ (–¥–æ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è —Å—Ç—Ä–∞—Ç–µ–≥–∏–π)
        self.experience_buffer: List[Experience] = []
        self.buffer_size = self.config.get("experience_buffer_size", 100)
        
        # –ö—ç—à —Å—Ç—Ä–∞—Ç–µ–≥–∏–π
        self.strategies_cache: Dict[str, Strategy] = {}
        
        # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã reinforcement
        self.confidence_boost = self.config.get("confidence_boost", 0.05)
        self.confidence_penalty = self.config.get("confidence_penalty", 0.1)
        self.exploration_rate = self.config.get("exploration_rate", 0.1)
        self.min_experiences = self.config.get("min_experiences_for_strategy", 3)
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # LOGGING EXPERIENCE
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    async def log_experience(
        self,
        task_description: str,
        task_type: str,
        context: Dict,
        action_taken: str,
        outcome: Outcome,
        reasoning: str,
        error_message: Optional[str] = None
    ) -> str:
        """
        –ó–∞–ø–∏—Å–∞—Ç—å –æ–ø—ã—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∑–∞–¥–∞—á–∏.
        
        Args:
            task_description: –û–ø–∏—Å–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏
            task_type: –¢–∏–ø –∑–∞–¥–∞—á–∏ (–¥–ª—è –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∏)
            context: –ö–æ–Ω—Ç–µ–∫—Å—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
            action_taken: –ß—Ç–æ –±—ã–ª–æ —Å–¥–µ–ª–∞–Ω–æ
            outcome: –†–µ–∑—É–ª—å—Ç–∞—Ç
            reasoning: –ü–æ—á–µ–º—É —Ç–∞–∫ —Å–¥–µ–ª–∞–ª–∏
            error_message: –°–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ (–µ—Å–ª–∏ failure)
        
        Returns:
            ID –∑–∞–ø–∏—Å–∞–Ω–Ω–æ–≥–æ –æ–ø—ã—Ç–∞
        """
        experience = Experience(
            id=str(uuid.uuid4()),
            task_description=task_description,
            task_type=task_type,
            context=context,
            action_taken=action_taken,
            outcome=outcome,
            reasoning=reasoning,
            error_message=error_message,
            timestamp=datetime.now()
        )
        
        # –î–æ–±–∞–≤–∏—Ç—å –≤ –±—É—Ñ–µ—Ä
        self.experience_buffer.append(experience)
        
        # –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤ –≥—Ä–∞—Ñ
        episode = Episode(
            id=f"exp_{experience.id}",
            content=json.dumps({
                "type": "experience",
                "task_type": task_type,
                "task_description": task_description,
                "action": action_taken,
                "outcome": outcome.value,
                "reasoning": reasoning,
                "error": error_message
            }),
            timestamp=experience.timestamp,
            source="experience_log",
            outcome=outcome.value,
            importance_score=1.0 if outcome == Outcome.FAILURE else 0.8
        )
        await self.graph.add_episode(episode)
        
        logger.info(
            f"Experience logged: {task_type} -> {outcome.value}"
        )
        
        # –ï—Å–ª–∏ –±—É—Ñ–µ—Ä –ø–æ–ª–æ–Ω ‚Äî –∏–∑–≤–ª–µ—á—å —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
        if len(self.experience_buffer) >= self.buffer_size:
            await self.extract_strategies()
        
        return experience.id
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # STRATEGY EXTRACTION
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    async def extract_strategies(self) -> List[Strategy]:
        """
        –ò–∑–≤–ª–µ—á—å —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –∏–∑ –Ω–∞–∫–æ–ø–ª–µ–Ω–Ω–æ–≥–æ –æ–ø—ã—Ç–∞.
        –ì—Ä—É–ø–ø–∏—Ä—É–µ—Ç –ø–æ task_type –∏ –Ω–∞—Ö–æ–¥–∏—Ç –ø–∞—Ç—Ç–µ—Ä–Ω—ã.
        
        Returns:
            –°–ø–∏—Å–æ–∫ –Ω–æ–≤—ã—Ö —Å—Ç—Ä–∞—Ç–µ–≥–∏–π
        """
        if not self.experience_buffer:
            return []
        
        # –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∞—Ç—å –ø–æ task_type
        by_task_type: Dict[str, List[Experience]] = {}
        for exp in self.experience_buffer:
            if exp.task_type not in by_task_type:
                by_task_type[exp.task_type] = []
            by_task_type[exp.task_type].append(exp)
        
        new_strategies = []
        
        for task_type, experiences in by_task_type.items():
            # –ù—É–∂–Ω–æ –º–∏–Ω–∏–º—É–º N –æ–ø—ã—Ç–æ–≤
            if len(experiences) < self.min_experiences:
                continue
            
            # –†–∞–∑–¥–µ–ª–∏—Ç—å –Ω–∞ —É—Å–ø–µ—à–Ω—ã–µ –∏ –Ω–µ—É–¥–∞—á–Ω—ã–µ
            successes = [e for e in experiences if e.outcome == Outcome.SUCCESS]
            failures = [e for e in experiences if e.outcome == Outcome.FAILURE]
            
            # –ò–∑–≤–ª–µ—á—å —Å—Ç—Ä–∞—Ç–µ–≥–∏—é –∏–∑ —É—Å–ø–µ—Ö–æ–≤
            if len(successes) >= 2:
                strategy = self._extract_from_successes(task_type, successes)
                if strategy:
                    new_strategies.append(strategy)
                    await self._save_strategy(strategy)
            
            # –ò–∑–≤–ª–µ—á—å anti-pattern –∏–∑ –Ω–µ—É–¥–∞—á
            if len(failures) >= 2:
                anti_strategy = self._extract_from_failures(task_type, failures)
                if anti_strategy:
                    new_strategies.append(anti_strategy)
                    await self._save_strategy(anti_strategy)
        
        # –û—á–∏—Å—Ç–∏—Ç—å –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–µ
        self.experience_buffer.clear()
        
        logger.info(f"Extracted {len(new_strategies)} strategies")
        return new_strategies
    
    def _extract_from_successes(
        self, 
        task_type: str, 
        successes: List[Experience]
    ) -> Optional[Strategy]:
        """–ò–∑–≤–ª–µ—á—å –ø–∞—Ç—Ç–µ—Ä–Ω —É—Å–ø–µ—Ö–∞"""
        # –ù–∞–π—Ç–∏ –æ–±—â–∏–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ actions
        actions = [e.action_taken for e in successes]
        common_words = self._find_common_keywords(actions)
        
        if not common_words:
            return None
        
        description = f"For {task_type}: {', '.join(common_words[:5])}"
        
        strategy = Strategy(
            id=str(uuid.uuid4()),
            description=description,
            task_types=[task_type],
            success_count=len(successes),
            failure_count=0,
            confidence=min(0.9, 0.5 + len(successes) * 0.1),
            metadata={"source": "success_extraction"}
        )
        
        self.strategies_cache[strategy.id] = strategy
        return strategy
    
    def _extract_from_failures(
        self, 
        task_type: str, 
        failures: List[Experience]
    ) -> Optional[Strategy]:
        """–ò–∑–≤–ª–µ—á—å anti-pattern (—á—Ç–æ –ù–ï –¥–µ–ª–∞—Ç—å)"""
        # –ù–∞–π—Ç–∏ –æ–±—â–∏–µ —ç–ª–µ–º–µ–Ω—Ç—ã –≤ actions
        actions = [e.action_taken for e in failures]
        common_words = self._find_common_keywords(actions)
        
        if not common_words:
            return None
        
        description = f"AVOID for {task_type}: {', '.join(common_words[:5])}"
        
        strategy = Strategy(
            id=str(uuid.uuid4()),
            description=description,
            task_types=[task_type],
            success_count=0,
            failure_count=len(failures),
            confidence=0.1,  # –ù–∏–∑–∫–∏–π confidence = –ù–ï –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å
            metadata={
                "source": "failure_extraction",
                "is_anti_pattern": True
            }
        )
        
        self.strategies_cache[strategy.id] = strategy
        return strategy
    
    def _find_common_keywords(self, texts: List[str]) -> List[str]:
        """–ù–∞–π—Ç–∏ –æ–±—â–∏–µ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞"""
        if not texts:
            return []
        
        # –ü—Ä–æ—Å—Ç–∞—è –≤–µ—Ä—Å–∏—è: —á–∞—Å—Ç–æ—Ç–Ω—ã–π –∞–Ω–∞–ª–∏–∑
        word_counts: Dict[str, int] = {}
        
        for text in texts:
            words = set(text.lower().split())
            for word in words:
                if len(word) > 3:  # –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å –∫–æ—Ä–æ—Ç–∫–∏–µ
                    word_counts[word] = word_counts.get(word, 0) + 1
        
        # –°–ª–æ–≤–∞, –≤—Å—Ç—Ä–µ—á–∞—é—â–∏–µ—Å—è –≤ >50% —Ç–µ–∫—Å—Ç–æ–≤
        threshold = len(texts) // 2
        common = [
            word for word, count in word_counts.items()
            if count > threshold
        ]
        
        return sorted(common, key=lambda w: word_counts[w], reverse=True)
    
    async def _save_strategy(self, strategy: Strategy) -> None:
        """–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å—Ç—Ä–∞—Ç–µ–≥–∏—é –≤ –≥—Ä–∞—Ñ"""
        episode = Episode(
            id=f"strategy_{strategy.id}",
            content=json.dumps(strategy.to_dict()),
            timestamp=strategy.created_at,
            source="strategy_extraction",
            importance_score=strategy.confidence,
            metadata={"type": "strategy"}
        )
        await self.graph.add_episode(episode)
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # STRATEGY RETRIEVAL
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    async def get_strategies_for_task(
        self,
        task_description: str,
        task_type: str = None,
        limit: int = 5
    ) -> List[Strategy]:
        """
        –ù–∞–π—Ç–∏ –ø–æ–¥—Ö–æ–¥—è—â–∏–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –¥–ª—è –∑–∞–¥–∞—á–∏.
        
        Args:
            task_description: –û–ø–∏—Å–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏
            task_type: –¢–∏–ø –∑–∞–¥–∞—á–∏ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
            limit: –ú–∞–∫—Å–∏–º—É–º —Å—Ç—Ä–∞—Ç–µ–≥–∏–π
        
        Returns:
            –°–ø–∏—Å–æ–∫ —Å—Ç—Ä–∞—Ç–µ–≥–∏–π, –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø–æ —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω–æ—Å—Ç–∏
        """
        # –ü–æ–∏—Å–∫ –≤ –≥—Ä–∞—Ñ–µ
        query = f"strategy {task_type or ''} {task_description}"
        results = await self.graph.search(query, limit=limit * 2)
        
        strategies = []
        for result in results:
            try:
                data = json.loads(result.content)
                if data.get("type") == "strategy" or "description" in data:
                    strategy = Strategy.from_dict(data)
                    
                    # –§–∏–ª—å—Ç—Ä anti-patterns —Å –Ω–∏–∑–∫–∏–º confidence
                    if strategy.confidence < 0.2:
                        # –≠—Ç–æ anti-pattern, –ø–æ–º–µ—Ç–∏—Ç—å
                        strategy.metadata["is_anti_pattern"] = True
                    
                    strategies.append(strategy)
            except:
                continue
        
        # –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: –≤—ã—Å–æ–∫–∏–π confidence –ø–µ—Ä–≤—ã–π
        strategies.sort(key=lambda s: s.confidence, reverse=True)
        
        return strategies[:limit]
    
    async def select_best_strategy(
        self,
        task_description: str,
        task_type: str = None,
        context: Dict = None
    ) -> Optional[Strategy]:
        """
        –í—ã–±—Ä–∞—Ç—å –ª—É—á—à—É—é —Å—Ç—Ä–∞—Ç–µ–≥–∏—é —Å —É—á—ë—Ç–æ–º exploration.
        
        Uses epsilon-greedy:
        - –° –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å—é epsilon ‚Üí —Å–ª—É—á–∞–π–Ω–∞—è —Å—Ç—Ä–∞—Ç–µ–≥–∏—è (exploration)
        - –ò–Ω–∞—á–µ ‚Üí –ª—É—á—à–∞—è –ø–æ confidence (exploitation)
        
        Returns:
            –õ—É—á—à–∞—è —Å—Ç—Ä–∞—Ç–µ–≥–∏—è –∏–ª–∏ None
        """
        strategies = await self.get_strategies_for_task(
            task_description, 
            task_type
        )
        
        if not strategies:
            return None
        
        # –§–∏–ª—å—Ç—Ä—É–µ–º anti-patterns
        good_strategies = [
            s for s in strategies 
            if not s.metadata.get("is_anti_pattern", False)
        ]
        
        if not good_strategies:
            return None
        
        # Epsilon-greedy selection
        if np.random.random() < self.exploration_rate:
            # Exploration: —Å–ª—É—á–∞–π–Ω—ã–π –≤—ã–±–æ—Ä
            selected = np.random.choice(good_strategies)
            logger.debug(f"Strategy selection: EXPLORATION -> {selected.id[:8]}")
        else:
            # Exploitation: –ª—É—á—à–∏–π –ø–æ confidence
            selected = max(good_strategies, key=lambda s: s.confidence)
            logger.debug(f"Strategy selection: EXPLOITATION -> {selected.id[:8]}")
        
        return selected
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # FEEDBACK & REINFORCEMENT
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    async def update_strategy_feedback(
        self,
        strategy_id: str,
        outcome: Outcome
    ) -> bool:
        """
        –û–±–Ω–æ–≤–∏—Ç—å —Å—Ç—Ä–∞—Ç–µ–≥–∏—é –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞.
        
        Positive reinforcement: —É—Å–ø–µ—Ö ‚Üí –ø–æ–≤—ã—Å–∏—Ç—å confidence
        Negative reinforcement: –Ω–µ—É–¥–∞—á–∞ ‚Üí –ø–æ–Ω–∏–∑–∏—Ç—å confidence
        
        Args:
            strategy_id: ID —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
            outcome: –†–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è
        
        Returns:
            True –µ—Å–ª–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–æ
        """
        # –ù–∞–π—Ç–∏ —Å—Ç—Ä–∞—Ç–µ–≥–∏—é
        strategy = self.strategies_cache.get(strategy_id)
        
        if not strategy:
            # –ü–æ–∏—Å–∫ –≤ –≥—Ä–∞—Ñ–µ
            results = await self.graph.search(
                f"strategy_{strategy_id}",
                limit=1
            )
            if results:
                try:
                    data = json.loads(results[0].content)
                    strategy = Strategy.from_dict(data)
                    self.strategies_cache[strategy_id] = strategy
                except:
                    return False
        
        if not strategy:
            logger.warning(f"Strategy not found: {strategy_id}")
            return False
        
        # –û–±–Ω–æ–≤–∏—Ç—å —Å—á—ë—Ç—á–∏–∫–∏
        if outcome == Outcome.SUCCESS:
            strategy.success_count += 1
            # Positive reinforcement
            strategy.confidence = min(
                1.0, 
                strategy.confidence + self.confidence_boost
            )
            logger.info(
                f"Strategy {strategy_id[:8]} SUCCESS: "
                f"confidence={strategy.confidence:.2f}"
            )
            
        elif outcome == Outcome.FAILURE:
            strategy.failure_count += 1
            # Negative reinforcement
            strategy.confidence = max(
                0.0,
                strategy.confidence - self.confidence_penalty
            )
            
            # –£—Å–∏–ª–∏–≤–∞—Ç—å penalty –ø—Ä–∏ —á–∞—Å—Ç—ã—Ö –Ω–µ—É–¥–∞—á–∞—Ö
            if strategy.failure_count > 5:
                strategy.confidence = max(
                    0.0,
                    strategy.confidence - self.confidence_penalty
                )
            
            logger.info(
                f"Strategy {strategy_id[:8]} FAILURE: "
                f"confidence={strategy.confidence:.2f}"
            )
        
        strategy.last_used = datetime.now()
        
        # –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ
        await self._save_strategy(strategy)
        
        return True
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # ANTI-PATTERNS
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    async def get_anti_patterns(
        self,
        task_type: str = None,
        limit: int = 5
    ) -> List[Strategy]:
        """
        –ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ anti-patterns (—á—Ç–æ –ù–ï –¥–µ–ª–∞—Ç—å).
        
        Returns:
            –°—Ç—Ä–∞—Ç–µ–≥–∏–∏ —Å –Ω–∏–∑–∫–∏–º confidence (–Ω–µ—É–¥–∞—á–Ω—ã–µ –ø–æ–¥—Ö–æ–¥—ã)
        """
        query = f"AVOID anti-pattern {task_type or ''}"
        results = await self.graph.search(query, limit=limit * 2)
        
        anti_patterns = []
        for result in results:
            try:
                data = json.loads(result.content)
                strategy = Strategy.from_dict(data)
                
                # –¢–æ–ª—å–∫–æ —Å –Ω–∏–∑–∫–∏–º confidence –∏–ª–∏ –ø–æ–º–µ—á–µ–Ω–Ω—ã–µ
                if (strategy.confidence < 0.3 or 
                    strategy.metadata.get("is_anti_pattern")):
                    anti_patterns.append(strategy)
            except:
                continue
        
        return anti_patterns[:limit]
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # –°–¢–ê–¢–ò–°–¢–ò–ö–ê
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    def get_stats(self) -> Dict:
        """–ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É"""
        return {
            "experience_buffer_size": len(self.experience_buffer),
            "strategies_cached": len(self.strategies_cache),
            "exploration_rate": self.exploration_rate,
            "avg_confidence": np.mean([
                s.confidence for s in self.strategies_cache.values()
            ]) if self.strategies_cache else 0
        }


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# SELF-LEARNING AGENT MIXIN
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class SelfLearningMixin:
    """
    Mixin –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Å–∞–º–æ–æ–±—É—á–µ–Ω–∏—è –∫ –∞–≥–µ–Ω—Ç—É.
    
    –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:
        class MyAgent(SelfLearningMixin):
            def __init__(self, reasoning_bank):
                self.reasoning_bank = reasoning_bank
            
            async def execute_task(self, task):
                return await self.execute_with_learning(task, self._do_task)
    """
    
    reasoning_bank: ReasoningBank
    
    async def execute_with_learning(
        self,
        task_description: str,
        task_type: str,
        execute_func,
        context: Dict = None
    ):
        """
        –í—ã–ø–æ–ª–Ω–∏—Ç—å –∑–∞–¥–∞—á—É —Å —Ü–∏–∫–ª–æ–º –æ–±—É—á–µ–Ω–∏—è.
        
        Args:
            task_description: –û–ø–∏—Å–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏
            task_type: –¢–∏–ø –∑–∞–¥–∞—á–∏
            execute_func: –§—É–Ω–∫—Ü–∏—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è (async callable)
            context: –ö–æ–Ω—Ç–µ–∫—Å—Ç
        
        Returns:
            –†–µ–∑—É–ª—å—Ç–∞—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
        """
        context = context or {}
        
        # 1. RETRIEVE: –ù–∞–π—Ç–∏ —Å—Ç—Ä–∞—Ç–µ–≥–∏—é
        strategy = await self.reasoning_bank.select_best_strategy(
            task_description,
            task_type,
            context
        )
        
        # 2. PLAN: –ü–æ–¥–≥–æ—Ç–æ–≤–∏—Ç—å –ø–ª–∞–Ω
        if strategy:
            plan = f"Using strategy: {strategy.description}"
            context["strategy_id"] = strategy.id
        else:
            plan = "No prior strategy, using default approach"
        
        # 3. EXECUTE
        outcome = Outcome.UNKNOWN
        error_message = None
        result = None
        
        try:
            result = await execute_func(task_description, context)
            outcome = Outcome.SUCCESS
            
        except Exception as e:
            outcome = Outcome.FAILURE
            error_message = str(e)
            logger.error(f"Task failed: {e}")
        
        # 4. LEARN: –ó–∞–ø–∏—Å–∞—Ç—å –æ–ø—ã—Ç
        await self.reasoning_bank.log_experience(
            task_description=task_description,
            task_type=task_type,
            context=context,
            action_taken=plan,
            outcome=outcome,
            reasoning=f"Executed with strategy: {strategy.id if strategy else 'none'}",
            error_message=error_message
        )
        
        # 5. UPDATE: –û–±–Ω–æ–≤–∏—Ç—å —Å—Ç—Ä–∞—Ç–µ–≥–∏—é
        if strategy:
            await self.reasoning_bank.update_strategy_feedback(
                strategy.id,
                outcome
            )
        
        return result
```

---

## 2Ô∏è‚É£ –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –∞–≥–µ–Ω—Ç–æ–º

### –§–∞–π–ª `src/agent.py` (–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ):

```python
"""
–ê–≥–µ–Ω—Ç —Å —Å–∞–º–æ–æ–±—É—á–µ–Ω–∏–µ–º.
"""

from .core.memory import FractalMemory
from .core.learning import ReasoningBank, SelfLearningMixin, Outcome


class AutonomousAgent(SelfLearningMixin):
    """
    –ê–≤—Ç–æ–Ω–æ–º–Ω—ã–π –∞–≥–µ–Ω—Ç —Å –ø–∞–º—è—Ç—å—é –∏ —Å–∞–º–æ–æ–±—É—á–µ–Ω–∏–µ–º.
    """
    
    def __init__(self, config: Dict):
        self.config = config
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–∞–º—è—Ç–∏
        self.memory = FractalMemory(config)
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –æ–±—É—á–µ–Ω–∏—è
        self.reasoning_bank = ReasoningBank(
            self.memory.graph,
            config.get("learning_config", {})
        )
        
        # LLM client
        self.llm = config.get("llm_client")
    
    async def initialize(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è"""
        await self.memory.initialize()
    
    async def chat(self, message: str) -> str:
        """
        –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è —Å –∑–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ–º.
        """
        # –ó–∞–ø–æ–º–Ω–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ
        await self.memory.remember(message)
        
        # –ù–∞–π—Ç–∏ —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç
        context = await self.memory.recall(message)
        
        # –ù–∞–π—Ç–∏ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ (–µ—Å–ª–∏ —ç—Ç–æ –∑–∞–¥–∞—á–∞)
        strategies = []
        if self._is_task(message):
            strategies = await self.reasoning_bank.get_strategies_for_task(
                message,
                task_type=self._detect_task_type(message)
            )
        
        # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–∞
        response = await self._generate_response(
            message, 
            context, 
            strategies
        )
        
        # –ó–∞–ø–æ–º–Ω–∏—Ç—å –æ—Ç–≤–µ—Ç
        await self.memory.remember(response)
        
        return response
    
    async def execute_task(
        self, 
        task: str, 
        task_type: str = "general"
    ):
        """
        –í—ã–ø–æ–ª–Ω–∏—Ç—å –∑–∞–¥–∞—á—É —Å –æ–±—É—á–µ–Ω–∏–µ–º.
        """
        return await self.execute_with_learning(
            task_description=task,
            task_type=task_type,
            execute_func=self._do_task,
            context={}
        )
    
    async def _do_task(self, task: str, context: Dict):
        """–†–µ–∞–ª—å–Ω–æ–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏"""
        # –ó–¥–µ—Å—å —Ç–≤–æ—è –ª–æ–≥–∏–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
        pass
    
    async def _generate_response(
        self, 
        message: str, 
        context: List,
        strategies: List
    ) -> str:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–∞ —á–µ—Ä–µ–∑ LLM"""
        # –ü–æ—Å—Ç—Ä–æ–∏—Ç—å –ø—Ä–æ–º–ø—Ç —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º –∏ —Å—Ç—Ä–∞—Ç–µ–≥–∏—è–º–∏
        prompt = self._build_prompt(message, context, strategies)
        
        if self.llm:
            return await self.llm.complete(prompt)
        else:
            return "LLM not configured"
    
    def _is_task(self, message: str) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∏—Ç—å —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –∑–∞–¥–∞—á–µ–π"""
        task_keywords = ["—Å–¥–µ–ª–∞–π", "—Å–æ–∑–¥–∞–π", "–Ω–∞–ø–∏—à–∏", "–∏—Å–ø—Ä–∞–≤—å", "do", "create", "write", "fix"]
        return any(kw in message.lower() for kw in task_keywords)
    
    def _detect_task_type(self, message: str) -> str:
        """–û–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ç–∏–ø –∑–∞–¥–∞—á–∏"""
        if "–∫–æ–¥" in message.lower() or "code" in message.lower():
            return "coding"
        elif "–¥–æ–∫—É–º–µ–Ω—Ç" in message.lower() or "doc" in message.lower():
            return "documentation"
        elif "–∞–Ω–∞–ª–∏–∑" in message.lower() or "analysis" in message.lower():
            return "analysis"
        return "general"
    
    def _build_prompt(
        self, 
        message: str, 
        context: List,
        strategies: List
    ) -> str:
        """–ü–æ—Å—Ç—Ä–æ–∏—Ç—å –ø—Ä–æ–º–ø—Ç"""
        parts = [f"User: {message}"]
        
        if context:
            parts.append("\nRelevant context:")
            for c in context[:3]:
                parts.append(f"- {c.content[:200]}")
        
        if strategies:
            parts.append("\nApplicable strategies:")
            for s in strategies[:2]:
                if s.confidence > 0.5:
                    parts.append(f"- DO: {s.description}")
                else:
                    parts.append(f"- AVOID: {s.description}")
        
        return "\n".join(parts)
```

---

## 3Ô∏è‚É£ –¢–µ—Å—Ç—ã

### –§–∞–π–ª `tests/test_learning.py`:

```python
"""
–¢–µ—Å—Ç—ã ReasoningBank.
"""

import pytest
from datetime import datetime
from src.core.learning import (
    ReasoningBank, 
    Strategy, 
    Experience, 
    Outcome
)
from src.core.graphiti_adapter import MockGraphMemory


@pytest.fixture
async def reasoning_bank():
    """–°–æ–∑–¥–∞—Ç—å ReasoningBank —Å mock"""
    graph = MockGraphMemory()
    await graph.initialize()
    
    bank = ReasoningBank(graph, {
        "min_experiences_for_strategy": 2,
        "exploration_rate": 0.1
    })
    
    return bank


class TestReasoningBank:
    
    @pytest.mark.asyncio
    async def test_log_experience(self, reasoning_bank):
        """log_experience –∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç –æ–ø—ã—Ç"""
        exp_id = await reasoning_bank.log_experience(
            task_description="Test task",
            task_type="testing",
            context={"key": "value"},
            action_taken="Did something",
            outcome=Outcome.SUCCESS,
            reasoning="Because"
        )
        
        assert exp_id is not None
        assert len(reasoning_bank.experience_buffer) == 1
    
    @pytest.mark.asyncio
    async def test_strategy_extraction(self, reasoning_bank):
        """extract_strategies –∏–∑–≤–ª–µ–∫–∞–µ—Ç –ø–∞—Ç—Ç–µ—Ä–Ω—ã"""
        # –î–æ–±–∞–≤–∏—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —É—Å–ø–µ—à–Ω—ã—Ö –æ–ø—ã—Ç–æ–≤
        for i in range(3):
            await reasoning_bank.log_experience(
                task_description=f"Task {i}",
                task_type="coding",
                context={},
                action_taken="Use Python and tests",
                outcome=Outcome.SUCCESS,
                reasoning="Standard approach"
            )
        
        # –ò–∑–≤–ª–µ—á—å —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
        strategies = await reasoning_bank.extract_strategies()
        
        assert len(strategies) >= 1
    
    @pytest.mark.asyncio
    async def test_negative_reinforcement(self, reasoning_bank):
        """–ù–µ—É–¥–∞—á–∏ —Å–Ω–∏–∂–∞—é—Ç confidence"""
        # –°–æ–∑–¥–∞—Ç—å —Å—Ç—Ä–∞—Ç–µ–≥–∏—é
        strategy = Strategy(
            id="test-strategy",
            description="Test strategy",
            task_types=["testing"],
            confidence=0.8
        )
        reasoning_bank.strategies_cache[strategy.id] = strategy
        await reasoning_bank._save_strategy(strategy)
        
        # –û–±–Ω–æ–≤–∏—Ç—å —Å –Ω–µ—É–¥–∞—á–µ–π
        await reasoning_bank.update_strategy_feedback(
            strategy.id,
            Outcome.FAILURE
        )
        
        # Confidence –¥–æ–ª–∂–µ–Ω —Å–Ω–∏–∑–∏—Ç—å—Å—è
        updated = reasoning_bank.strategies_cache[strategy.id]
        assert updated.confidence < 0.8
        assert updated.failure_count == 1
    
    @pytest.mark.asyncio
    async def test_positive_reinforcement(self, reasoning_bank):
        """–£—Å–ø–µ—Ö–∏ –ø–æ–≤—ã—à–∞—é—Ç confidence"""
        strategy = Strategy(
            id="test-strategy-2",
            description="Test strategy 2",
            task_types=["testing"],
            confidence=0.5
        )
        reasoning_bank.strategies_cache[strategy.id] = strategy
        await reasoning_bank._save_strategy(strategy)
        
        # –û–±–Ω–æ–≤–∏—Ç—å —Å —É—Å–ø–µ—Ö–æ–º
        await reasoning_bank.update_strategy_feedback(
            strategy.id,
            Outcome.SUCCESS
        )
        
        updated = reasoning_bank.strategies_cache[strategy.id]
        assert updated.confidence > 0.5
        assert updated.success_count == 1


class TestStrategy:
    
    def test_success_rate(self):
        """success_rate —Å—á–∏—Ç–∞–µ—Ç—Å—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ"""
        strategy = Strategy(
            id="test",
            description="Test",
            task_types=[],
            success_count=7,
            failure_count=3
        )
        
        assert strategy.success_rate == 0.7
    
    def test_serialization(self):
        """to_dict/from_dict —Ä–∞–±–æ—Ç–∞—é—Ç"""
        original = Strategy(
            id="test",
            description="Test strategy",
            task_types=["a", "b"],
            success_count=5,
            failure_count=2,
            confidence=0.75
        )
        
        data = original.to_dict()
        restored = Strategy.from_dict(data)
        
        assert restored.id == original.id
        assert restored.description == original.description
        assert restored.success_count == original.success_count
```

---

## ‚úÖ –ö—Ä–∏—Ç–µ—Ä–∏–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è Phase 3

- [ ] `ReasoningBank` —Å–æ–∑–¥–∞–Ω
- [ ] `log_experience()` –∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç –æ–ø—ã—Ç
- [ ] `extract_strategies()` –∏–∑–≤–ª–µ–∫–∞–µ—Ç –ø–∞—Ç—Ç–µ—Ä–Ω—ã
- [ ] `update_strategy_feedback()` –æ–±–Ω–æ–≤–ª—è–µ—Ç confidence
- [ ] Negative reinforcement —Ä–∞–±–æ—Ç–∞–µ—Ç (–Ω–µ—É–¥–∞—á–∏ —Å–Ω–∏–∂–∞—é—Ç confidence)
- [ ] –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –∞–≥–µ–Ω—Ç–æ–º —Ä–∞–±–æ—Ç–∞–µ—Ç
- [ ] –¢–µ—Å—Ç—ã –ø—Ä–æ—Ö–æ–¥—è—Ç: `pytest tests/test_learning.py -v`

---

## üìö –°–ª–µ–¥—É—é—â–∏–π —à–∞–≥

–ü–µ—Ä–µ–π–¥–∏ –∫: **[05_PHASE4_PRODUCTION.md](05_PHASE4_PRODUCTION.md)** ‚Äî –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∏ production
